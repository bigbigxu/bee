<?php
/**
 * Created by PhpStorm.
 * User: VigoXu
 * Date: 2016/1/19
 * Time: 10:16
 * 如果使用无序集合来保存iD，使用sort命令来取得数据。需要要求
 * set hash数据不能有过期时间。不然数据过期，会影响sort命令返回结果的正确性。
 * sort排序方式，会占用大量内存，所以此类放弃了这种方式。
 *
 * 设计说明：
 *    1.使用hash表来保存一数据库中对应的一条记录。
 *    2.使用有序集合来保存索引。就是id为value，对应字段值为score。
 *    3.这里都是先更新cache，然后更新mysql。如果mysql更新失败，会回滚cache，但是并不保证cache回滚成功。
 *    4.同时保存hash,set可能会占用较多内存。过大数据可能不适合。
 *    5.这里为索引设定的过期时间。如果索引过期，需要遍历整个mysql表来重建索引。
 *    6.异步更新mysql,最好基于swoole写个server来实现，定时器也是可选的方案，但不可靠。
 *    7.索引的更新，最好使用其它服务来定时检查。
 *    8.大数据下，冷热数据的区分，目前没有想到比较好的实现方法。也许可以基本规则判断数据是否进入cache
 *
 * 此类的作用：
 *    1.统一cache ,mysql操作，减少代码量，增加可复用性,，并保证Mysql数据和redis数据的一致性。
 *    2.统一管理的cache ，key。
 *    3.事实上，也可以只使用redis
 * @TODO 未经测试，不要使用
 * @TODO 不支持联合主键
 */
class CacheRedis extends CoreModel
{
    /**
     * 创建索引的有序集合的过期时间
     * @var int
     */
    protected $indexExpire = 604800;
    /**
     * 数据hash表的过期时间
     * @var int
     */
    protected $dataExpire = 604800;
    /**
     * 索引key的前缀
     * @var string
     */
    protected $indexKeyPrefix = 'auto_index_';
    /**
     * 数据key的前缀
     * @var string
     */
    protected $dataKeyPrefix = 'auto_data_';
    /**
     * 分组key的前缀
     * @var string
     */
    protected $groupKeyPrefix = 'auto_group_';
    /**
     * 全局的key前缀。默认使用表名
     * @var string
     */
    protected $globalKeyPrefix = '';
    /**
     * 保存下一个自增长id的key
     * @var string
     */
    protected $nextIdKey = 'next_id';
    /**
     * 获取id 锁
     * @var string
     */
    protected $idLockKey = 'next_id_lock';
    /**
     * 数据库更新模式，默认使用同步模式
     * @var string
     */
    public $mysqlMode = self::MYSQL_SYNC;
    protected $redisQuery = array(
        'field' => '', //查询的字段，数组形式
        'sort' => self::SORT_ASC, //排序类型
        'limit' => array(), //开始位置
        'min' => '-inf', //索引最小值
        'max' => '+inf', //索引最大值
        'index' => '', //使用的索引
        'group' => '', //使用的分组
    );
    /**
     * 是否自动重建索引
     * @var bool
     */
    protected $autoCreateIndex = true;
    /**
     * 最后一次查询的相关选面
     * @var array
     */
    protected $lastQuery = array();
    const OP_INSERT = 1; //插入数据
    const OP_UPDATE = 2; //更新数据
    const OP_DEL = 3; //删除数据
    const OP_FIND = 4; //查找数据
    const OP_CACHE = 5; //更新cache

    const MYSQL_ASYNC = 'async'; //当前使用异步mysql更新模式
    const MYSQL_SYNC = 'sync'; //同步模式
    const MYSQL_NONE = 'none'; //不使用Mysql来处理数据。

    const ERR_OP_CACHE = 1; //更新cache失败
    const ERR_OP_MYSQL = 2; //更新数据库失败

    const SORT_DESC = 'desc';
    const SORT_ASC = 'asc';

    /**
     * 异步mysql回调函数。函数接受3个参数，主键,数据,操作类型
     * @var mixed
     */
    protected $mysqlCallback;
    protected $redisCli = 'redis-cli'; //redis客户端命令路径

    /**
     * 定义数据字段，如果为空，表示所有字段
     * @return array
     */
    public function dataField()
    {
        return array();
    }

    /**
     * 索引字段。这将产生多个有续集合。
     * @return array
     */
    public function indexField()
    {
        return array();
    }

    /**
     * 设定group分组。通常于用描述Mysql表之间的关系
     * @example
     * array(
     *    //表示使用mid进行分级time为score 的zset
     *   'mid' => 'time',
     * )
     */
    public function groupField()
    {
        return array();
    }

    /**
     * 初始化方法。
     * 用于检查表名配置和设置redis全局前缀
     * @throws Exception
     */
    public function init()
    {
        $name = $this->tableName();
        if ($name == false) {
            throw new Exception("请定义表名！");
        }
        if ($this->globalKeyPrefix == false) {
            $this->globalKeyPrefix = $this->tableName() . '_';
        }
        $this->setErrMode(PDO::ERRMODE_SILENT); //设置errmode为静默处理。用于回滚cache
        $this->db()->setAttr(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, true);
    }

    /**
     * 得到主键名称。通常情况建议定义值
     * @return mixed
     */
    public function getPkName()
    {
        return parent::getPkName(); // TODO: Change the autogenerated stub
    }

    /**
     * 向数据库插入一条记录。同时更新cache
     * 如果data中，已经有主键的值，将直接使用主键的值。如果没有，将取当前表id的最大值。
     * 对于使用了分表的主键。应该将主键值放在data数组中。
     * @param array $data 要插入的数据
     * @return bool
     */
    public function cacheInsert($data)
    {
        $pk = $data[$this->getPkName()]; //数据中已经有了主键
        if ($pk == false) {
            $pk = $this->getNextId();
        }

        if ($this->_cache($pk, $data, self::OP_INSERT) == false) {
            return $this->setErrno(self::ERR_OP_CACHE);
        }

        //更新mysql
        if ($this->mysqlMode == self::MYSQL_SYNC) { //同步更新模式
            if ($this->insert($data) === false) {
                $this->cacheDelete($pk);
                self::errorLog($this->getDbErrmsg());
                return $this->setErrno(self::ERR_OP_MYSQL);
            }
        } elseif ($this->mysqlMode == self::MYSQL_ASYNC) { //异步mysql。调用指定的回调函数
            return call_user_func($this->mysqlCallback, $pk, $data, self::OP_INSERT);
        }
        return true;
    }

    /**
     * 基于主键更新一条记录
     * @param $pk
     * @param $data
     * @return array|bool
     */
    public function cacheUpdate($pk, $data)
    {
        $beforeData = $this->cacheOne($pk); //之前的数据。
        if ($this->_cache($pk, $data, self::OP_UPDATE, $beforeData) == false) {
            return $this->setErrno(self::ERR_OP_CACHE);
        }

        //更新mysql
        if ($this->mysqlMode == self::MYSQL_SYNC) { //同步更新模式
            if ($this->updateById($data, $pk) === false) {
                $this->_cache($pk, $beforeData, self::OP_UPDATE); //数据回滚
                self::errorLog($this->getDbErrmsg());
                return $this->setErrno(self::ERR_OP_MYSQL);
            }
        } elseif ($this->mysqlMode == self::MYSQL_ASYNC) { //异步mysql。调用指定的回调函数
            return call_user_func($this->mysqlCallback, $pk, $data, self::OP_UPDATE);
        }
        return true;
    }


    /**
     * 基于主键删除一条记录
     * @param $pk
     * @return bool|false|mixed
     */
    public function cacheDelete($pk)
    {
        $data = $this->cacheOne($pk);
        $indexField = $this->indexField();
        $groupField = $this->groupField();

        if ($indexField) { //删除索引
            foreach ($indexField as $field) {
                $cacheKey = $this->cacheIndexKey($field);
                $this->redis()->zRem($cacheKey, $pk);
            }
        }

        if ($groupField) {
            foreach ($groupField as $k => $v) { //删除分组
                $cacheKey = $this->cacheGroupKey($k, $data[$k]);
                $this->redis()->zRem($cacheKey, $pk);
            }
        }

        $this->redis()->del($this->cacheDataKey($pk));
        //删除mysql
        if ($this->mysqlMode == self::MYSQL_SYNC) { //同步更新模式
            if ($this->delById($pk) === false) {
                $this->cacheInsert($data); //重新更新cache
                self::errorLog($this->getDbErrmsg());
                return $this->setErrno(self::ERR_OP_MYSQL);
            }
        } elseif ($this->mysqlMode == self::MYSQL_ASYNC) { //异步mysql。调用指定的回调函数
            return call_user_func($this->mysqlCallback, $pk, $data, self::OP_DEL);
        }
        return true;
    }

    /**
     * 内部hash cache更新函数
     * @param $pk
     * @param array $data
     * @param int $op
     * @param $beforeData
     * @return array
     */
    private function _cache($pk, $data = array(), $op = self::OP_CACHE, $beforeData = array())
    {
        if ($data == false && $this->mysqlMode != self::MYSQL_NONE) {
            $data = $this->findById($pk);
        }
        if ($this->updateData($pk, $data) == false) {
            return false;
        }
        if ($op != self::OP_FIND) { //查询操作不需要更新索引
            $flag1 = $this->updateIndex($pk, $data, $beforeData);
            $flag2 = $this->updateGroup($pk, $data, $beforeData);
            return $flag1 && $flag2;
        } else {
            return $data;
        }
    }

    /**
     * 更新分组信息
     * @param $pk
     * @param $data
     * @param array $beforeData
     * @return bool
     */
    public function updateGroup($pk, $data, $beforeData = array())
    {
        $groupField = $this->groupField();
        if ($groupField == false) {
            return true;
        }
        $flag = true;
        foreach ($groupField as $field => $score) {
            if (array_key_exists($field, $data) == false) {
                continue; //如果更新的字段不在分组字段中。
            }
            $cacheKey = $this->cacheGroupKey($field, $data[$field]);
            $beforeCacheKey = $this->cacheGroupKey($field, $beforeData[$field]);

            if ($data[$field] != $beforeData[$field]) { //数据分组发生改变
                $this->redis()->zRem($beforeCacheKey, $pk); //从旧的分组中删除
            }

            $flag = $this->redis()->zAdd($cacheKey, $data[$score], $pk);
            $this->redis()->expire($cacheKey, $this->indexExpire);
        }
        return $flag;
    }

    /**
     * 更新hash表数据字段
     * @param $pk
     * @param $data
     * @return bool
     * @throws Exception
     */
    public function updateData($pk, $data)
    {
        $dataField = $this->dataField();
        $dataKey = $this->cacheDataKey($pk);

        if ($dataField != false) { //只保存指定字段的数据
            $data = Functions::arrayFilterKey($data, $dataField);
        }
        $flag = $this->redis()->hMset($dataKey, $data);
        $this->redis()->expire($dataKey, $this->dataExpire);
        return $flag;
    }

    /**
     * 更新索引
     * @param mixed $pk 主键
     * @param array $data 要更新的数据
     * @param array $beforeData 更新之前的数据
     * @return null
     */
    public function updateIndex($pk, $data, $beforeData = array())
    {
        $indexField = $this->indexField();
        if ($indexField == false) {
            return true;
        }
        $flag = true;
        foreach ($indexField as $field) {
            if (in_array($field, $data) == false) {
                continue; //当前更新的字段不保含索引
            }
            if ($beforeData[$field] != $data[$field]) { //新旧值不一样，才需要更新cache
                $cacheKey = $this->cacheIndexKey($field);
                $flag = $this->redis()->zAdd($cacheKey, $data[$field], $pk);
                $this->redis()->expire($cacheKey, $this->indexExpire);
            }
        }
        return $flag;
    }

    /**
     * 得到记当详情hash表的key
     * @param $id
     * @return string
     */
    public function cacheDataKey($id)
    {
        return $this->globalKeyPrefix . $this->dataKeyPrefix . $id;
    }

    public function cacheGroupKey($field, $value)
    {
        return $this->globalKeyPrefix . $this->groupKeyPrefix . $field . "_" . $value;
    }

    /**
     * 得到索引集合的key
     * @param string $field 字段名称
     * @return string
     */
    public function cacheIndexKey($field)
    {
        return "{$this->globalKeyPrefix }{$this->indexKeyPrefix}{$field}";
    }


    /**
     * 获取自增长id的锁
     * @param int $timeout 超时间，单位ms
     * @return bool
     */
    private function _nextIdLock($timeout = 1000)
    {
        $count = $timeout % 100;
        $i = 0;
        while ($this->redis()->get($this->idLockKey)) {
            $i++;
            usleep(100);
            if ($i > $count) {
                return false;
            }
        }
        return true;
    }

    /**
     * 得到下一次自增加ID。此方法也可以解并发插入自增长id锁表问题
     * 默认会使用当前表的ID。如果使用了其它方法。可能需要重写此方法
     * @param int $timeout 超时时间
     * @return int
     * @throws Exception
     */
    public function getNextId($timeout = 1000)
    {
        if ($this->_nextIdLock($timeout) == false) {
            throw new Exception("获取自增加ID超时");
        }
        $id = $this->redis()->incr($this->nextIdKey);
        if ($id > 1) { //ID大于1表示key存在。
            return $id;
        }
        if ($this->redis()->setnx($this->idLockKey, 1)) { //得到id锁
            $this->redis()->expire($this->idLockKey, $this->indexExpire);
            $id = $this->from()->max($this->getPkName());
            $id++;
            $this->redis()->set($this->nextIdKey, $id);
            $this->redis()->del($this->idLockKey);
            return $id;
        } else {
            throw new Exception("获取自增加失败");
        }
    }

    /**
     * 注册mysql回写函数
     * @param $callback
     * @return $this
     */
    public function registerMysqlCallback($callback)
    {
        $this->mysqlCallback = $callback;
        return $this;
    }


    /**
     * 根据主键查找一条记录
     * @param $pk
     * @param bool|true $checkCache
     * @return array|bool|false|string
     */
    public function cacheOne($pk, $checkCache = true)
    {
        $r = false;
        if ($checkCache) {
            $r = $this->redis()->hGetAll($this->cacheDataKey($pk));
        }
        if ($r == false) { //如果cache不存在
            $r = $this->_cache($pk, array(), self::OP_FIND);
        }
        return $r;
    }

    /**
     * 设置查询的索引字段
     * @param $index
     * @return $this
     */
    public function cacheIndex($index)
    {
        $this->redisQuery['index'] = $index;
        $this->redisQuery['group'] = '';
        return $this;
    }

    /**
     * 设置技术查询的group字段
     * 志明 index, group只能存在一个
     * @param $field
     * @param $value
     * @return $this
     */
    public function cacheGroup($field, $value)
    {
        $this->redisQuery['group'] = array($field, $value);
        $this->redisQuery['index'] = '';
        return $this;
    }

    /**
     * 这个方法是limit方法的变种
     * @param int $page 当前页
     * @param int $pageSize 每页数量
     * @return $this
     */
    public function cachePage($page = 0, $pageSize = 20)
    {
        $pageSize = $pageSize <= 0 ? 20 : $pageSize;
        $page = $page <= 0 ? 1 : $page;
        $offset = ($page - 1) * $pageSize;
        $this->cacheLimit($offset, $pageSize);
        return $this;
    }

    /**
     * 设置获取数据偏移量
     * @param int $offset
     * @param int $limit
     * @return $this
     */
    public function cacheLimit($offset = 0, $limit = 10)
    {
        $this->redisQuery['limit'] = array($offset, $limit);
        return $this;
    }

    /**
     * 设置排序类型
     * @param $type
     * @return $this
     */
    public function cacheSort($type)
    {
        $this->redisQuery['sort'] = $type;
        return $this;
    }

    /**
     * 设置查询的字端
     * @param $field
     * @return $this
     */
    public function cacheField($field)
    {
        $this->redisQuery['field'] = $field;
        return $this;
    }

    /**
     * 从cache查找所有数据
     * @param array $query
     * @return array
     * @throws Exception
     */
    public function cacheAll($query = array())
    {
        $this->redisQuery = array_merge($this->redisQuery, $query);
        $r = array();
        if ($this->redisQuery['index'] && in_array($this->redisQuery['index'], $this->indexField())) {
            $indexKey = $this->cacheIndexKey($this->redisQuery['index']);
        } elseif ($this->redisQuery['group'] && array_key_exists($this->redisQuery['group'][0], $this->groupField())) {
            $indexKey = $this->cacheGroupKey($this->redisQuery['group'][0], $this->redisQuery['group'][1]);
        } else {
            throw new Exception('未定义的索引或分组');
        }

        //是否自动重建索引
        if ($this->redis()->exists($indexKey) == false) {
            if ($this->autoCreateIndex) {
                if ($this->redisQuery['index']) {
                    $this->buildIndex($this->redisQuery['index']);
                } elseif ($this->redisQuery['group']) {
                    $this->buildGroup($this->redisQuery['group'][0]);
                }
            } else {
                throw new Exception("索引或分组不存在");
            }
        }
        $min = $this->redisQuery['min'];
        $max = $this->redisQuery['max'];
        $limit = $this->redisQuery['limit'];
        if ($this->redisQuery['sort'] == self::SORT_DESC) {
            $idArr = $this->redis()->zRevRangeByScore($indexKey, $min, $max, array('limit' => $limit));
        } else {
            $idArr = $this->redis()->zRangeByScore($indexKey, $min, $max, array('limit' => $limit));
        }
        foreach ((array)$idArr as $id) {
            $item = $this->cacheOne($id);
            if ($this->redisQuery['field']) {
                $item = Functions::arrayFilterKey($item, $this->redisQuery['field']);
            }
            $r[] = $item;
        }
        $this->clearQuery();
        return $r;
    }

    /**
     * 一次查询执行后，清量相关参数
     */
    public function clearQuery()
    {
        $this->lastQuery = $this->redisQuery;
        $this->redisQuery = array(
            'field' => '', //查询的字段，数组形式
            'sort' => self::SORT_ASC, //排序类型
            'limit' => array(), //开始位置
            'min' => '-inf', //索引最小值
            'max' => '+inf', //索引最大值
            'index' => '',
            'group' => ''
        );
    }

    /**
     * 创建指定字段的索引
     * @param string $field 要创建索引的字段
     * @param PDOStatement()|null $stmt 一个stmt对象。如果为空，将遍历整个表。
     */
    public function buildIndex($field, $stmt = null)
    {
        if ($stmt === null) {
            $stmt = $this->from()->query();
        }
        $indexKey = $this->cacheIndexKey($field);
        $pkName = $this->getPkName();
        foreach ($stmt as $row) {
            $this->redis()->zAdd($indexKey, $row[$field], $row[$pkName]);
        }
        $this->redis()->expire($indexKey, $this->indexExpire);
    }

    /**
     * 创建分组索引
     * @param $field
     * @param $stmt
     */
    public function buildGroup($field, $stmt = null)
    {
        if ($stmt === null) {
            $stmt = $this->from()->query();
        }
        $pkName = $this->getPkName();
        foreach ($stmt as $row) {
            $groupKey = $this->cacheGroupKey($field, $row[$field]);
            $this->redis()->zAdd($groupKey, $row[$field], $row[$pkName]);
            $this->redis()->expire($groupKey, $this->indexExpire);
        }
    }

    /**
     * 设置选项。
     * @param $key
     * @param $value
     * @return $this
     */
    public function setOption($key, $value)
    {
        $vars = get_class_vars($this);
        if (in_array($key, $vars)) {
            $this->$key = $value;
        }
        return $this;
    }

    /**
     * 设置多个选项
     * @param $options
     * @return $this
     */
    public function setOptions($options)
    {
        foreach ($options as $key => $value) {
            $this->setOption($key, $value);
        }
        return $this;
    }

    /**
     * 设置全局cache key的前缀
     * 此方法不可以在类实例后更改。只能在子类中重写init方法。
     * @param $key
     * @return $this
     */
    public function setGlobalKeyPrefix($key)
    {
        $this->globalKeyPrefix = $key;
        return $this;
    }

    /**
     * 得到全局cache key的前缀
     * @return string
     */
    public function getGlobalKeyPrefix()
    {
        return $this->globalKeyPrefix;
    }


    /**
     * 设置索引cache的前缀
     * @param $key
     * @return $this
     */
    public function setIndexKeyPrefix($key)
    {
        $this->indexKeyPrefix = $key;
        return $this;
    }

    /**
     * 创建一个Key
     * 函数接受多个参数。会在前面加上前缀。
     * @return string
     */
    public function createKey()
    {
        $params = func_get_args();
        $key = $this->globalKeyPrefix . implode('_', $params);
        return $key;
    }

    /**
     * 设置cli命令执行路径
     * @param $cli
     * @return $this
     */
    public function setRedisCli($cli)
    {
        $this->redisCli = $cli;
        return $this;
    }

    /**
     * 删除缓存的索引
     * @return string
     */
    public function delCacheIndex()
    {
        $params = func_get_args();
        if (count($params) == 0) {
            return false;
        }
        foreach ($params as $field) {
            $key = $this->cacheIndexKey($field);
            $this->redis()->del($key);
        }
        return true;
    }

    /**
     * 删除一个分组key
     * @param $field
     * @param $value
     */
    public function delCacheGroup($field, $value)
    {
        $key = $this->cacheGroupKey($field, $value);
        $this->redis()->delKeysCmd($key);
    }

    /**
     * 删除所有数据。
     */
    public function delCacheData()
    {
        $keys = "{$this->globalKeyPrefix}{$this->indexKeyPrefix}*";
        $cmd = $this->redis()->delKeysCmd($keys, $this->redisCli);
        echo shell_exec($cmd);
    }

    public function errorLog($msg)
    {
        CoreLog::error($msg);
    }

    /**
     * 删除所有数据
     */
    public function delAll()
    {
        if ($this->globalKeyPrefix == false) {
            throw new Exception('cache前缀不能为空');
        }
        $keys = "{$this->globalKeyPrefix}*";
        $cmd = $this->redis()->delKeysCmd($keys, $this->redisCli);
        echo shell_exec($cmd);
    }
}